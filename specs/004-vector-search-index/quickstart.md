# Quickstart: Vector Search Index Infrastructure

**Feature**: 004-vector-search-index
**Created**: 2025-12-29

## Overview

This guide walks you through setting up and using the Qdrant vector search index infrastructure for music tracks. You'll learn how to start Qdrant, initialize the index schema, and run tests.

## Prerequisites

- **Node.js**: 20.x or later
- **Docker**: With Docker Compose
- **Operating System**: macOS or Linux

## Setup

### 1. Install Dependencies

From the repository root:

```bash
cd services/search-index
npm install
```

This installs:
- `qdrant-js` - Qdrant TypeScript client
- `zod` - Schema validation
- `vitest` - Testing framework
- Development dependencies (TypeScript, ESLint)

### 2. Start Qdrant

From the repository root:

```bash
docker compose up qdrant -d
```

This starts Qdrant with:
- **Port**: 6333 (HTTP API) and 6334 (gRPC)
- **Volume**: `./data/qdrant` (persisted data)
- **Memory Limit**: 4GB
- **CPU Limit**: 2 cores

Verify Qdrant is running:

```bash
curl http://localhost:6333/
```

Expected response:
```json
{
  "title": "qdrant - vector search engine",
  "version": "1.7.0"
}
```

### 3. Initialize the Index

Create the `tracks` collection with the schema:

```bash
cd services/search-index
npx tsx src/scripts/initIndex.ts tracks
```

Expected output:
```
[initIndex] Connecting to Qdrant at http://localhost:6333...
[initIndex] Collection 'tracks' does not exist. Creating...
[initIndex] Created collection 'tracks' with 4096-dim dense + sparse vectors
[initIndex] Created payload indexes: isrc (keyword), title/artist/lyrics/interpretation (text)
✓ Collection 'tracks' initialized successfully
  Vectors: 0
  Indexes: 5
```

**What this does:**
- Creates Qdrant collection named `tracks`
- Configures 4096-dimensional dense vectors (`interpretation_embedding`)
- Configures sparse vectors for BM25 text search (`text_sparse`)
- Creates payload indexes for ISRC lookup and text search
- Applies int8 quantization for memory efficiency

### 4. Verify Index

Check the collection exists:

```bash
curl http://localhost:6333/collections/tracks
```

Expected response includes:
```json
{
  "result": {
    "name": "tracks",
    "vectors_count": 0,
    "points_count": 0,
    "status": "green",
    "config": {
      "params": {
        "vectors": {
          "interpretation_embedding": {
            "size": 4096,
            "distance": "Cosine"
          }
        }
      }
    }
  }
}
```

## Running Tests

### Run All Tests

```bash
npm test
```

This executes:
- **Contract tests**: Schema validation, ISRC uniqueness, data type enforcement
- **Integration tests**: Docker connectivity, index initialization, insert/update/search operations

Expected output:
```
 ✓ tests/contract/schema.test.ts (5 tests)
 ✓ tests/integration/initialization.test.ts (3 tests)
 ✓ tests/integration/operations.test.ts (8 tests)

Test Files  3 passed (3)
     Tests  16 passed (16)
  Start at  12:34:56
  Duration  3.42s
```

### Run Specific Test Suite

```bash
npm test -- tests/contract/schema.test.ts
```

### Watch Mode (TDD)

```bash
npm run test:watch
```

This re-runs tests on file changes (useful during development).

### Type Checking

```bash
npm run type-check
```

Verifies TypeScript compilation without emitting files.

## Usage Examples

### Example 1: Insert a Track Document

```typescript
import { QdrantClient } from '@qdrant/js-client-rest';
import { hashIsrcToUuid } from './src/scripts/testUtils';

const client = new QdrantClient({ url: 'http://localhost:6333' });

const track = {
  isrc: 'USRC17607839',
  title: 'Bohemian Rhapsody',
  artist: 'Queen',
  album: 'A Night at the Opera',
  lyrics: '...',  // Full lyrics
  interpretation: 'Epic rock ballad about existential themes...',
  interpretation_embedding: new Array(4096).fill(0.1),  // From Qwen3-Embedding-8B
  acousticness: 0.2,
  energy: 0.8,
  valence: 0.6
};

const pointId = hashIsrcToUuid(track.isrc);

await client.upsert('tracks', {
  points: [
    {
      id: pointId,
      vector: {
        interpretation_embedding: track.interpretation_embedding,
        // text_sparse generated by BM25 tokenizer (future ingestion pipeline)
      },
      payload: {
        isrc: track.isrc,
        title: track.title,
        artist: track.artist,
        album: track.album,
        lyrics: track.lyrics,
        interpretation: track.interpretation,
        acousticness: track.acousticness,
        energy: track.energy,
        valence: track.valence
      }
    }
  ]
});

console.log(`Inserted track: ${track.title} (${track.isrc})`);
```

### Example 2: Vector Similarity Search

Find tracks semantically similar to a query:

```typescript
const queryEmbedding = new Array(4096).fill(0.15);  // From embedding model

const results = await client.search('tracks', {
  vector: {
    name: 'interpretation_embedding',
    vector: queryEmbedding
  },
  limit: 10,
  with_payload: true
});

results.forEach(result => {
  console.log(`${result.payload.title} by ${result.payload.artist} (score: ${result.score})`);
});
```

### Example 3: ISRC Lookup

Retrieve a specific track by ISRC:

```typescript
const isrc = 'USRC17607839';
const pointId = hashIsrcToUuid(isrc);

const result = await client.retrieve('tracks', {
  ids: [pointId],
  with_payload: true,
  with_vector: false
});

if (result.length > 0) {
  const track = result[0].payload;
  console.log(`Found: ${track.title} by ${track.artist}`);
} else {
  console.log('Track not found');
}
```

### Example 4: Filtered Search

Search with audio feature filters:

```typescript
const results = await client.search('tracks', {
  vector: {
    name: 'interpretation_embedding',
    vector: queryEmbedding
  },
  filter: {
    must: [
      { key: 'energy', range: { gte: 0.7 } },       // High energy
      { key: 'danceability', range: { gte: 0.6 } }, // Danceable
      { key: 'mode', match: { value: 1 } }          // Major key
    ]
  },
  limit: 10
});
```

## Common Tasks

### Reinitialize Index (Fresh Start)

Delete and recreate the collection:

```bash
# Delete existing collection
curl -X DELETE http://localhost:6333/collections/tracks

# Recreate with schema
npx tsx src/scripts/initIndex.ts tracks
```

**Warning**: This deletes all indexed tracks. Use with caution.

### View Collection Statistics

```bash
curl http://localhost:6333/collections/tracks | jq .result.points_count
```

Shows number of indexed tracks.

### Access Qdrant Dashboard

Open in browser: http://localhost:6333/dashboard

Features:
- Collection browser
- Query console
- Index statistics
- Performance metrics

## Troubleshooting

### Qdrant Not Running

**Symptom**: `connect ECONNREFUSED 127.0.0.1:6333`

**Solution**:
```bash
docker compose up qdrant -d
docker compose logs qdrant
```

### Schema Mismatch

**Symptom**: `Collection exists with different schema`

**Solution**: The collection was created with different vector dimensions or config. Delete and recreate:
```bash
curl -X DELETE http://localhost:6333/collections/tracks
npx tsx src/scripts/initIndex.ts tracks
```

### Out of Memory

**Symptom**: Qdrant container crashes or OOM errors

**Solution**: Qdrant is configured with 4GB limit. For larger corpus (>100k tracks), adjust `docker-compose.yml`:
```yaml
services:
  qdrant:
    mem_limit: 8g  # Increase as needed
```

### Test Collection Not Cleaned Up

**Symptom**: Test collections persist after test run

**Solution**: Run cleanup script (future implementation) or manually delete:
```bash
curl http://localhost:6333/collections | jq -r '.result.collections[].name' | grep 'tracks-test-' | xargs -I {} curl -X DELETE http://localhost:6333/collections/{}
```

### TypeScript Errors

**Symptom**: Type errors during development

**Solution**:
```bash
npm run type-check
```

Fix errors shown in output. Common issues:
- Missing Zod schema validation
- Incorrect vector dimensions (must be 4096)
- Payload type mismatches

## Performance Tuning

### Monitor Query Latency

```bash
curl http://localhost:6333/metrics
```

Look for `qdrant_search_time_seconds` metric.

### Check Memory Usage

```bash
docker stats qdrant
```

Expected memory for 100k corpus: ~2-3GB (with int8 quantization).

### Optimize HNSW Parameters

If search is slow (>500ms), adjust in `src/schema/trackCollection.ts`:

```typescript
hnsw_config: {
  hnsw_ef: 256  // Increase from 128 for better recall at cost of latency
}
```

Reinitialize collection after changes.

## Next Steps

- **Ingestion Pipeline** (Future Feature): Populate index with real track data from Tidal API + Qwen3-Embedding-8B
- **Search API** (Future Feature): GraphQL/REST API exposing search operations
- **Frontend Integration** (Future Feature): Music search UI consuming search API

## Resources

- [Qdrant Documentation](https://qdrant.tech/documentation/)
- [qdrant-js Client Reference](https://github.com/qdrant/qdrant-js)
- [Feature Specification](./spec.md)
- [Data Model](./data-model.md)
- [Contracts](./contracts/)

## Getting Help

- Check [Troubleshooting](#troubleshooting) section
- Review test files for usage examples: `tests/integration/operations.test.ts`
- Qdrant Discord: https://discord.gg/qdrant
- GitHub Issues: Create issue in algojuke repository with `search-index` label
